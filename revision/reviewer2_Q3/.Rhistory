bmdd_fit_on_combo <- readRDS("bmdd_fit_on_combo.rds")
fit <- bmdd_fit_on_combo$res[[1]]
pi <- fit$pi
alp0 <- fit$alpha$alp0
alp1 <- fit$alpha$alp1
m <- 100
n <- 80
del <- matrix(rbinom(m * n, 1, pi), m)
beta <- alp0 * (1 - del) + alp1 * del
X <- matrix(rgamma(m * n, beta, 1), m)
X1 <- t(t(X) / colSums(X))
X <- matrix(rgamma(m * n, beta, 10), m)
X2 <- t(t(X) / colSums(X))
plot(X1, X2)
plot(X1-X2)
nsim <- 10
m <- 100
n <- 80
a <- 1000
b <- 0.5
q <- 6
r <- 0
###########################
type <- 'Theoretical'
s <- 1
setup <- 'S1'
source('simu_fun.R')
source('simu_fun.R')
nsim <- 10
m <- 100
n <- 80
a <- 1000
b <- 0.5
q <- 6
r <- 0
###########################
type <- 'Theoretical'
s <- 1
setup <- 'S1'
source('simu_fun.R')
nsim <- 10
m <- 100
n <- 80
a <- 1000
b <- 0.5
q <- 6
r <- 0
###########################
type <- 'Theoretical'
s <- 1
setup <- 'S1'
source('simu_fun.R')
output.raw <- foreach(i = 1 : nsim, .combine = 'cbind') %do% {
res <- readRDS(paste0(output.folder, i, ".rds"))
res$res
}
output.raw.use <- output.raw[-c(2, 3, 18 : 34), ]
est <- rowMeans(output.raw.use)
est.sd <-  sqrt(rowSums((output.raw.use - est) ^ 2) / ((nsim - 1) * nsim))
saveRDS(cbind(est, est.sd), paste0(output.folder, "result_rho_1_rho_10.rds"))
output <- cbind(est, est.sd)
M <- ifelse(output > .001, sprintf("%.4f", output), sprintf("%.2e", output))
M
output.raw
nsim <- 10
m <- 100
n <- 80
a <- 1000
b <- 0.5
q <- 6
r <- 0
###########################
type <- 'Theoretical'
s <- 1
setup <- 'S1'
if(type %in% c('Theoretical', 'Theoretical2')) {
bmdd_fit_on_combo <- readRDS("bmdd_fit_on_combo.rds")
fit <- bmdd_fit_on_combo$res[[s]]
pi <- fit$pi
alp0 <- fit$alpha$alp0
alp1 <- fit$alpha$alp1
Z <- NULL
U <- NULL
if(s == 2) {
Z <- bmdd_fit_on_combo$cova$Z1
} else if(s == 3) {
Z <- bmdd_fit_on_combo$cova$Z2
} else if(s == 4) {
U <- bmdd_fit_on_combo$cova$U1
} else if(s == 5) {
U <- bmdd_fit_on_combo$cova$U2
}
if(type == 'Theoretical2') {
fun <- function(s, alp) {
if(s == 2) {
Z1 <- as.integer(as.factor(Z)) - 1
Y1 <- t(log(alp))
X1 <- rbind(rep(1, n), Z1)
} else if(s == 3) {
Z1 <- Z
Y1 <- t(log(alp))
X1 <- rbind(rep(1, n), Z1)
} else if(s == 4) {
Z1 <- as.integer(as.factor(U)) - 1
Y1 <- log(alp)
X1 <- rbind(rep(1, m), Z1)
} else if(s == 5) {
Z1 <- U
Y1 <- log(alp)
X1 <- rbind(rep(1, m), Z1)
}
regr <- coef(lm(Y1 ~ Z1))
regr[1, ] <- regr[1, ] / 2
regr[2, ] <- regr[2, ] + abs(regr[1, ]) * (regr[2, ] > 0) -
abs(regr[1, ]) * (regr[2, ] < 0)
alp <- exp(t(regr) %*% X1)
if(s %in% c(4, 5)) {
alp <- t(alp)
}
return(alp)
}
alp0 <- fun(s, alp0)
alp1 <- fun(s, alp1)
}
} else if(type == 'Non-parametric') {
rds <- readRDS('CDI_IBD_RA_SMOKE.rds')
if (ref == 'CDI') {
otu.tab <- rds$CDI.otu
} else if(ref == 'IBD') {
otu.tab <- rds$IBD.otu
} else if(ref == 'RA') {
otu.tab <- rds$RA.otu
} else if(ref == 'SMOKE') {
otu.tab <- rds$SMOKE.otu
}
}
library(BMDD)
library(DescTools)
library(gdata)
source('competing_fun.R')
source('evaluate_fun.R')
data1 <- data.generation(alp0, alp1, pi, m, n, a, b, q, r, Z, U, rho=1)
data2 <- data.generation(alp0, alp1, pi, m, n, a, b, q, r, Z, U, rho=10)
source('data_generation.R')
data1 <- data.generation(alp0, alp1, pi, m, n, a, b, q, r, Z, U, rho=1)
data2 <- data.generation(alp0, alp1, pi, m, n, a, b, q, r, Z, U, rho=10)
W1 <- data1$W
X1 <- data1$X
# Z <- data$Z
# U <- data$U
# if(!is.null(Z)) Z <- data.frame(Z)
# if(!is.null(U)) U <- data.frame(U)
W2 <- data2$W
X2 <- data2$X
Xhat.list1 <- competing.fun(W1)
res1 <- evaluate.fun(Xhat.list1, X1)
res1
Xhat.list2 <- competing.fun(W2)
res2 <- evaluate.fun(Xhat.list2, X2)
res2
cbind(res1, res2)
output.raw <- foreach(i = 1 : nsim, .combine = 'rbind') %do% {
res <- readRDS(paste0(output.folder, i, ".rds"))
res$res
}
output.raw
s <- nrow(output.raw) / nsim
output <- foreach (i = 1 : s, .combine = 'rbind') %do% {
res <- output.raw[seq(i, nsim * s, s), ]
est <- colMeans(res, na.rm = TRUE)
num.nan <- colSums(matrix(!is.na(res), nrow = nsim))
est.sd <- sqrt(rowSums((t(res) - est) ^ 2, na.rm = TRUE) / ((num.nan - 1) * num.nan))
return(c(est, est.sd))
}
output
library(foreach)
library(xtable)
parentheses <- function(x){
sprintf("(%s)", x)
}
tab.fun <- function(setup, m = NULL, n = NULL, a = NULL, b = NULL, q = NULL, r = NULL,
nsim, method, metric, type, robust = FALSE) {
if(type == 'Non-parametric') {
output.folder <- paste0('output/', setup, '/m_', m, '_n_', n, '/')
} else {
output.folder <- paste0('output/', setup, '/m_', m, '_n_', n, '_a_', a,
'_b_', b, '_q_', q, '_r_', r, '/')
}
output.raw <- foreach(i = 1 : nsim, .combine = 'rbind') %do% {
res <- readRDS(paste0(output.folder, i, ".rds"))
res$res
}
s <- nrow(output.raw) / nsim
# k <- s / 2
# l <- ncol(output.raw)
#
# if(l == 11) {
#   ind <- c(1, 4, 8, 2, 3, 5 : 7, 9 : 11)
# } else if(l == 14) {
#   ind <- c(1, 12, 4, 8, 2, 13, 3, 14, 5 : 7, 9 : 11)
# } else if(l == 12) {
#   ind <- c(1, 12, 4, 8, 2, 3, 5 : 7, 9 : 11)
# }
# method <- method[ind]
# output.raw <- output.raw[, ind]
output <- foreach (i = 1 : s, .combine = 'rbind') %do% {
res <- output.raw[seq(i, nsim * s, s), ]
est <- colMeans(res, na.rm = TRUE)
num.nan <- colSums(matrix(!is.na(res), nrow = nsim))
est.sd <- sqrt(rowSums((t(res) - est) ^ 2, na.rm = TRUE) / ((num.nan - 1) * num.nan))
return(c(est, est.sd))
}
M <- ifelse(output > .001, sprintf("%.4f", output), sprintf("%.2e", output))
M[, (l + 1) : (2 * l)] <- parentheses(M[, (l + 1) : (2 * l)])
v <- rep(0, s); v[c(2, 3, 2 + k, 3 + k)] <- 1
ord <- t(sapply(1 : s, function(i) {
order(output[i, 1 : l], decreasing = v[i])
}))
ind1 <- ord[, 1]
ind2 <- ord[, 2]
# for(i in 1 : s) {
#   #M[i, ind1[i]] <- paste0(M[i, ind1[i]], '*')
#   #M[i, ind2[i]] <- paste0(M[i, ind2[i]], '**')
#   M[i, ind1[i]] <- paste0('{\\color{red}\\textbf{', M[i, ind1[i]], '}}')
#   M[i, ind2[i]] <- paste0('{\\color{red}', M[i, ind2[i]], '}')
# }
M <- foreach(i = 1 : l, .combine = 'cbind') %do% {
paste(M[, i], M[, i + l], sep = '')
}
colnames(M) <- method
rownames(M) <- rep(metric, 2)
if(!robust) {
table_latex <- xtable(M[1 : k, ])
} else {
table_latex <- xtable(M[(k + 1) : (2 * k), ])
}
print(table_latex, include.rownames = TRUE, comment = FALSE,
sanitize.text.function = function(x) x)
}
method <- c('BMDD1', 'BMDD2')
metric <- c('Mean squared error', 'Sample-wise correlation', 'Taxon-wise correlation',
'Sample-wise distance', 'Taxon-wise distance',
'Shannon\'s index', 'Simpson\'s index', 'Bray-Curtis dissimilarity',
'Kullback–Leibler divergence', 'Jensen–Shannon divergence', 'Hellinger distance',
'Gini coefficient', '(Mean, Standard deviation)', 'Coefficient of variation',
'Kolmogorov–Smirnov distance', 'Wasserstein distance', 'Pairwise taxon-to-taxon correlation')
nsim <- 10
m <- 100
n <- 80
a <- 1000
b <- 0.5
q <- 6
r <- 0
tab.fun('S1', m, n, a, b, q, r, nsim, method, metric, type = 'Theoretical')
tab.fun <- function(setup, m = NULL, n = NULL, a = NULL, b = NULL, q = NULL, r = NULL,
nsim, method, metric, type, robust = FALSE) {
if(type == 'Non-parametric') {
output.folder <- paste0('output/', setup, '/m_', m, '_n_', n, '/')
} else {
output.folder <- paste0('output/', setup, '/m_', m, '_n_', n, '_a_', a,
'_b_', b, '_q_', q, '_r_', r, '/')
}
output.raw <- foreach(i = 1 : nsim, .combine = 'rbind') %do% {
res <- readRDS(paste0(output.folder, i, ".rds"))
res$res
}
s <- nrow(output.raw) / nsim
# k <- s / 2
l <- ncol(output.raw)
#
# if(l == 11) {
#   ind <- c(1, 4, 8, 2, 3, 5 : 7, 9 : 11)
# } else if(l == 14) {
#   ind <- c(1, 12, 4, 8, 2, 13, 3, 14, 5 : 7, 9 : 11)
# } else if(l == 12) {
#   ind <- c(1, 12, 4, 8, 2, 3, 5 : 7, 9 : 11)
# }
# method <- method[ind]
# output.raw <- output.raw[, ind]
output <- foreach (i = 1 : s, .combine = 'rbind') %do% {
res <- output.raw[seq(i, nsim * s, s), ]
est <- colMeans(res, na.rm = TRUE)
num.nan <- colSums(matrix(!is.na(res), nrow = nsim))
est.sd <- sqrt(rowSums((t(res) - est) ^ 2, na.rm = TRUE) / ((num.nan - 1) * num.nan))
return(c(est, est.sd))
}
M <- ifelse(output > .001, sprintf("%.4f", output), sprintf("%.2e", output))
M[, (l + 1) : (2 * l)] <- parentheses(M[, (l + 1) : (2 * l)])
v <- rep(0, s); v[c(2, 3, 2 + k, 3 + k)] <- 1
ord <- t(sapply(1 : s, function(i) {
order(output[i, 1 : l], decreasing = v[i])
}))
ind1 <- ord[, 1]
ind2 <- ord[, 2]
# for(i in 1 : s) {
#   #M[i, ind1[i]] <- paste0(M[i, ind1[i]], '*')
#   #M[i, ind2[i]] <- paste0(M[i, ind2[i]], '**')
#   M[i, ind1[i]] <- paste0('{\\color{red}\\textbf{', M[i, ind1[i]], '}}')
#   M[i, ind2[i]] <- paste0('{\\color{red}', M[i, ind2[i]], '}')
# }
M <- foreach(i = 1 : l, .combine = 'cbind') %do% {
paste(M[, i], M[, i + l], sep = '')
}
colnames(M) <- method
rownames(M) <- rep(metric, 2)
if(!robust) {
table_latex <- xtable(M[1 : k, ])
} else {
table_latex <- xtable(M[(k + 1) : (2 * k), ])
}
print(table_latex, include.rownames = TRUE, comment = FALSE,
sanitize.text.function = function(x) x)
}
method <- c('BMDD1', 'BMDD2')
metric <- c('Mean squared error', 'Sample-wise correlation', 'Taxon-wise correlation',
'Sample-wise distance', 'Taxon-wise distance',
'Shannon\'s index', 'Simpson\'s index', 'Bray-Curtis dissimilarity',
'Kullback–Leibler divergence', 'Jensen–Shannon divergence', 'Hellinger distance',
'Gini coefficient', '(Mean, Standard deviation)', 'Coefficient of variation',
'Kolmogorov–Smirnov distance', 'Wasserstein distance', 'Pairwise taxon-to-taxon correlation')
nsim <- 10
m <- 100
n <- 80
a <- 1000
b <- 0.5
q <- 6
r <- 0
tab.fun('S1', m, n, a, b, q, r, nsim, method, metric, type = 'Theoretical')
tab.fun <- function(setup, m = NULL, n = NULL, a = NULL, b = NULL, q = NULL, r = NULL,
nsim, method, metric, type, robust = FALSE) {
if(type == 'Non-parametric') {
output.folder <- paste0('output/', setup, '/m_', m, '_n_', n, '/')
} else {
output.folder <- paste0('output/', setup, '/m_', m, '_n_', n, '_a_', a,
'_b_', b, '_q_', q, '_r_', r, '/')
}
output.raw <- foreach(i = 1 : nsim, .combine = 'rbind') %do% {
res <- readRDS(paste0(output.folder, i, ".rds"))
res$res
}
s <- nrow(output.raw) / nsim
k <- s / 2
l <- ncol(output.raw)
#
# if(l == 11) {
#   ind <- c(1, 4, 8, 2, 3, 5 : 7, 9 : 11)
# } else if(l == 14) {
#   ind <- c(1, 12, 4, 8, 2, 13, 3, 14, 5 : 7, 9 : 11)
# } else if(l == 12) {
#   ind <- c(1, 12, 4, 8, 2, 3, 5 : 7, 9 : 11)
# }
# method <- method[ind]
# output.raw <- output.raw[, ind]
output <- foreach (i = 1 : s, .combine = 'rbind') %do% {
res <- output.raw[seq(i, nsim * s, s), ]
est <- colMeans(res, na.rm = TRUE)
num.nan <- colSums(matrix(!is.na(res), nrow = nsim))
est.sd <- sqrt(rowSums((t(res) - est) ^ 2, na.rm = TRUE) / ((num.nan - 1) * num.nan))
return(c(est, est.sd))
}
M <- ifelse(output > .001, sprintf("%.4f", output), sprintf("%.2e", output))
M[, (l + 1) : (2 * l)] <- parentheses(M[, (l + 1) : (2 * l)])
v <- rep(0, s); v[c(2, 3, 2 + k, 3 + k)] <- 1
ord <- t(sapply(1 : s, function(i) {
order(output[i, 1 : l], decreasing = v[i])
}))
ind1 <- ord[, 1]
ind2 <- ord[, 2]
# for(i in 1 : s) {
#   #M[i, ind1[i]] <- paste0(M[i, ind1[i]], '*')
#   #M[i, ind2[i]] <- paste0(M[i, ind2[i]], '**')
#   M[i, ind1[i]] <- paste0('{\\color{red}\\textbf{', M[i, ind1[i]], '}}')
#   M[i, ind2[i]] <- paste0('{\\color{red}', M[i, ind2[i]], '}')
# }
M <- foreach(i = 1 : l, .combine = 'cbind') %do% {
paste(M[, i], M[, i + l], sep = '')
}
colnames(M) <- method
rownames(M) <- rep(metric, 2)
if(!robust) {
table_latex <- xtable(M[1 : k, ])
} else {
table_latex <- xtable(M[(k + 1) : (2 * k), ])
}
print(table_latex, include.rownames = TRUE, comment = FALSE,
sanitize.text.function = function(x) x)
}
method <- c('BMDD1', 'BMDD2')
metric <- c('Mean squared error', 'Sample-wise correlation', 'Taxon-wise correlation',
'Sample-wise distance', 'Taxon-wise distance',
'Shannon\'s index', 'Simpson\'s index', 'Bray-Curtis dissimilarity',
'Kullback–Leibler divergence', 'Jensen–Shannon divergence', 'Hellinger distance',
'Gini coefficient', '(Mean, Standard deviation)', 'Coefficient of variation',
'Kolmogorov–Smirnov distance', 'Wasserstein distance', 'Pairwise taxon-to-taxon correlation')
nsim <- 10
m <- 100
n <- 80
a <- 1000
b <- 0.5
q <- 6
r <- 0
tab.fun('S1', m, n, a, b, q, r, nsim, method, metric, type = 'Theoretical')
nsim <- 10
m <- 100
n <- 80
a <- 1000
b <- 0.5
q <- 6
r <- 0
###########################
type <- 'Theoretical'
s <- 1
setup <- 'S1'
source('simu_fun.R')
nsim <- 10
m <- 100
n <- 80
a <- 1000
b <- 0.5
q <- 6
r <- 0
###########################
type <- 'Theoretical'
s <- 1
setup <- 'S1'
source('simu_fun.R')
library(foreach)
library(xtable)
parentheses <- function(x){
sprintf("(%s)", x)
}
tab.fun <- function(setup, m = NULL, n = NULL, a = NULL, b = NULL, q = NULL, r = NULL,
nsim, method, metric, type, robust = FALSE) {
if(type == 'Non-parametric') {
output.folder <- paste0('output/', setup, '/m_', m, '_n_', n, '/')
} else {
output.folder <- paste0('output/', setup, '/m_', m, '_n_', n, '_a_', a,
'_b_', b, '_q_', q, '_r_', r, '/')
}
output.raw <- foreach(i = 1 : nsim, .combine = 'rbind') %do% {
res <- readRDS(paste0(output.folder, i, ".rds"))
res$res
}
s <- nrow(output.raw) / nsim
k <- s / 2
l <- ncol(output.raw)
#
# if(l == 11) {
#   ind <- c(1, 4, 8, 2, 3, 5 : 7, 9 : 11)
# } else if(l == 14) {
#   ind <- c(1, 12, 4, 8, 2, 13, 3, 14, 5 : 7, 9 : 11)
# } else if(l == 12) {
#   ind <- c(1, 12, 4, 8, 2, 3, 5 : 7, 9 : 11)
# }
# method <- method[ind]
# output.raw <- output.raw[, ind]
output <- foreach (i = 1 : s, .combine = 'rbind') %do% {
res <- output.raw[seq(i, nsim * s, s), ]
est <- colMeans(res, na.rm = TRUE)
num.nan <- colSums(matrix(!is.na(res), nrow = nsim))
est.sd <- sqrt(rowSums((t(res) - est) ^ 2, na.rm = TRUE) / ((num.nan - 1) * num.nan))
return(c(est, est.sd))
}
M <- ifelse(output > .001, sprintf("%.4f", output), sprintf("%.2e", output))
M[, (l + 1) : (2 * l)] <- parentheses(M[, (l + 1) : (2 * l)])
v <- rep(0, s); v[c(2, 3, 2 + k, 3 + k)] <- 1
ord <- t(sapply(1 : s, function(i) {
order(output[i, 1 : l], decreasing = v[i])
}))
ind1 <- ord[, 1]
ind2 <- ord[, 2]
# for(i in 1 : s) {
#   #M[i, ind1[i]] <- paste0(M[i, ind1[i]], '*')
#   #M[i, ind2[i]] <- paste0(M[i, ind2[i]], '**')
#   M[i, ind1[i]] <- paste0('{\\color{red}\\textbf{', M[i, ind1[i]], '}}')
#   M[i, ind2[i]] <- paste0('{\\color{red}', M[i, ind2[i]], '}')
# }
M <- foreach(i = 1 : l, .combine = 'cbind') %do% {
paste(M[, i], M[, i + l], sep = '')
}
colnames(M) <- method
rownames(M) <- rep(metric, 2)
if(!robust) {
table_latex <- xtable(M[1 : k, ])
} else {
table_latex <- xtable(M[(k + 1) : (2 * k), ])
}
print(table_latex, include.rownames = TRUE, comment = FALSE,
sanitize.text.function = function(x) x)
}
method <- c('BMDD1', 'BMDD2')
metric <- c('Mean squared error', 'Sample-wise correlation', 'Taxon-wise correlation',
'Sample-wise distance', 'Taxon-wise distance',
'Shannon\'s index', 'Simpson\'s index', 'Bray-Curtis dissimilarity',
'Kullback–Leibler divergence', 'Jensen–Shannon divergence', 'Hellinger distance',
'Gini coefficient', '(Mean, Standard deviation)', 'Coefficient of variation',
'Kolmogorov–Smirnov distance', 'Wasserstein distance', 'Pairwise taxon-to-taxon correlation')
nsim <- 10
m <- 100
n <- 80
a <- 1000
b <- 0.5
q <- 6
r <- 0
tab.fun('S1', m, n, a, b, q, r, nsim, method, metric, type = 'Theoretical')
?rgamma
rgamma(10, 0.2, 1)
rgamma(10, 0.2, 10)
rgamma(10, 0.2, 100)
mean( rgamma(10, 0.2, 1))
mean(rgamma(10, 0.2, 10))
mean(rgamma(10, 0.2, 100))

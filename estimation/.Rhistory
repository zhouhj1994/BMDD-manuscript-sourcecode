j <- ind[k]
x <- X[j, ]
x <- x[x < quantile(x, 0.97)]
x1 <- seq(min(x), max(x), len = 1000)
y1 <- dbeta(x1, theta[j], theta.sum - theta[j])
x2 <- Xhat[j, ]
x2 <- x2[x2 < quantile(x2, 0.97)]
adj <- c(0.5, 1, 0.5, 0.5)
y.max <- c(30, 250, 20000, 15000)
gp <- ggplot() +
geom_histogram(aes(x = x, y = ..density..), #boundary = 0,
fill = 'steelblue', color = 'black') +
xlab('') + ylab('') +
theme_minimal(base_size = 25) +
geom_line(aes(x = x1, y = y1, color = "Dirichlet distribution"), size = 1.2) +
scale_y_continuous(limits = c(0, y.max[k])) +
stat_density(aes(x = x2, color = "BMDD"), size = 1.2, adjust = adj[k],
geom = "line", position = "identity") +
scale_color_manual(
name = "",
values = c("Dirichlet distribution" = "blue", "BMDD" = "red")
) +
theme(legend.position = "top")
if(k == 3) {
gp <- gp +
scale_x_continuous(
breaks = c(0, 0.00025, 0.0005, 0.00075),
labels = c("0e+00", "2.5e−04", "5e−04", "7.5e−04")
)
}
return(gp)
}
p1 <- plot.fun(1)
p2 <- plot.fun(2)
p3 <- plot.fun(3)
p4 <- plot.fun(4)
big_plot <- ggarrange(plotlist = list(p1, p2, p3, p4),
nrow = 2, ncol = 2, common.legend = TRUE)
final_plot <- annotate_figure(
big_plot,
bottom = text_grob("Proportion", size = 25),
left = text_grob("Density", size = 25, rot = 90)
)
pdf('fit_gp.pdf', width = 11, height = 8)
final_plot
dev.off()
pdf('fit_gp.pdf', width = 12, height = 8)
final_plot
dev.off()
###########################################################
library(foreach)
library(ggplot2)
fig.fun <- function(setup, m = NULL, n = NULL, a = NULL, b = NULL, q = NULL, r = NULL,
nsim, method, metric, type, robust = FALSE) {
if(type == 'Non-parametric') {
output.folder <- paste0('output/', setup, '/m_', m, '_n_', n, '/')
} else {
output.folder <- paste0('output/', setup, '/m_', m, '_n_', n, '_a_', a,
'_b_', b, '_q_', q, '_r_', r, '/')
}
output.raw <- foreach(i = 1 : nsim, .combine = 'rbind') %do% {
res <- readRDS(paste0(output.folder, i, ".rds"))
res$res
}
s <- nrow(output.raw) / nsim
k <- s / 2
l <- ncol(output.raw)
if(l == 11) {
ind <- c(1, 4, 8, 2, 3, 5 : 7, 9 : 11)
} else if(l == 14) {
ind <- c(1, 12, 4, 8, 2, 13, 3, 14, 5 : 7, 9 : 11)
} else if(l == 12) {
ind <- c(1, 12, 4, 8, 2, 3, 5 : 7, 9 : 11)
}
method <- method[ind]
output.raw <- output.raw[, ind]
output <- foreach (i = 1 : s, .combine = 'rbind') %do% {
res <- output.raw[seq(i, nsim * s, s), ]
est <- colMeans(res, na.rm = TRUE)
num.nan <- colSums(matrix(!is.na(res), nrow = nsim))
est.sd <- sqrt(rowSums((t(res) - est) ^ 2, na.rm = TRUE) / ((num.nan - 1) * num.nan))
return(c(est, est.sd))
}
M <- output[1 : k, 1 : l][-c(2, 3), ]
tmp1 <- (M[, -1] - M[, 1]) / M[, -1]
tmp2 <- (M[, 1] - M[, -1]) / M[, 1]
A <- tmp1 * (tmp1 > 0) - tmp2 * (tmp2 > 0)
colnames(A) <- method[-1]
A[A < 0] <- A[A < 0] / 10
method1 <- factor(1 : (l - 1), labels = method[-1])
df <- data.frame(method = rep(method1, each = k - 2),
value = as.vector(A))
custom_breaks <- c(1, 0.5, 0, -0.05, -0.1)
custom_labels <- c("100%", "50%", "0%", "50%", "100%")
pdf(paste0(setup,'_boxplot_gp.pdf'), width = 11, height = 8)
gp <- ggplot(df, aes(x = method, y = value))  +
geom_boxplot(fill = "steelblue", color = "black", na.rm = TRUE) +
theme_minimal(base_size = 25) +
scale_y_continuous(
breaks = custom_breaks,
labels = custom_labels
) +
xlab("") +
ylab("BMDD Improvement Percentage") +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
plot.margin = unit(c(0.5,0.5,-0.5,0.5), "cm")) +
geom_hline(yintercept = 0, color = "black", linetype = "dashed", size = 1)
print(gp)
dev.off()
}
method <- c('BMDD', 'mbDenoise', 'mbImpute', 'SAVER', 'scImpute', 'ALRA', 'DMM',
'naive-1', 'naive-2', 'naive-3', 'naive-4')
metric <- c('Mean squared error', 'Sample-wise correlation', 'Taxon-wise correlation',
'Sample-wise distance', 'Taxon-wise distance',
'Shannon\'s index', 'Simpson\'s index', 'Bray-Curtis dissimilarity',
'Kullback–Leibler divergence', 'Jensen–Shannon divergence', 'Hellinger distance',
'Gini coefficient', '(Mean, Standard deviation)', 'Coefficient of variation',
'Kolmogorov–Smirnov distance', 'Wasserstein distance', 'Pairwise taxon-to-taxon correlation')
nsim <- 10
m <- 100
n <- 80
a <- 1000
b <- 0.5
q <- 6
r <- 0
fig.fun('S1', m, n, a, b, q, r, nsim, method, metric, type = 'Theoretical')
fig.fun <- function(setup, m = NULL, n = NULL, a = NULL, b = NULL, q = NULL, r = NULL,
nsim, method, metric, type, robust = FALSE) {
if(type == 'Non-parametric') {
output.folder <- paste0('output/', setup, '/m_', m, '_n_', n, '/')
} else {
output.folder <- paste0('output/', setup, '/m_', m, '_n_', n, '_a_', a,
'_b_', b, '_q_', q, '_r_', r, '/')
}
output.raw <- foreach(i = 1 : nsim, .combine = 'rbind') %do% {
res <- readRDS(paste0(output.folder, i, ".rds"))
res$res
}
s <- nrow(output.raw) / nsim
k <- s / 2
l <- ncol(output.raw)
if(l == 11) {
ind <- c(1, 4, 8, 2, 3, 5 : 7, 9 : 11)
} else if(l == 14) {
ind <- c(1, 12, 4, 8, 2, 13, 3, 14, 5 : 7, 9 : 11)
} else if(l == 12) {
ind <- c(1, 12, 4, 8, 2, 3, 5 : 7, 9 : 11)
}
method <- method[ind]
output.raw <- output.raw[, ind]
output <- foreach (i = 1 : s, .combine = 'rbind') %do% {
res <- output.raw[seq(i, nsim * s, s), ]
est <- colMeans(res, na.rm = TRUE)
num.nan <- colSums(matrix(!is.na(res), nrow = nsim))
est.sd <- sqrt(rowSums((t(res) - est) ^ 2, na.rm = TRUE) / ((num.nan - 1) * num.nan))
return(c(est, est.sd))
}
M <- output[1 : k, 1 : l][-c(2, 3), ]
tmp1 <- (M[, -1] - M[, 1]) / M[, -1]
tmp2 <- (M[, 1] - M[, -1]) / M[, 1]
A <- tmp1 * (tmp1 > 0) - tmp2 * (tmp2 > 0)
colnames(A) <- method[-1]
A[A < 0] <- A[A < 0] / 10
method1 <- factor(1 : (l - 1), labels = method[-1])
df <- data.frame(method = rep(method1, each = k - 2),
value = as.vector(A))
custom_breaks <- c(1, 0.5, 0, -0.05, -0.1)
custom_labels <- c("100%", "50%", "0%", "50%", "100%")
pdf(paste0(setup,'_boxplot_gp.pdf'), width = 12, height = 8)
gp <- ggplot(df, aes(x = method, y = value))  +
geom_boxplot(fill = "steelblue", color = "black", na.rm = TRUE) +
theme_minimal(base_size = 25) +
scale_y_continuous(
breaks = custom_breaks,
labels = custom_labels
) +
xlab("") +
ylab("BMDD Improvement Percentage") +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
plot.margin = unit(c(0.5,0.5,-0.5,0.5), "cm")) +
geom_hline(yintercept = 0, color = "black", linetype = "dashed", size = 1)
print(gp)
dev.off()
}
fig.fun('S1', m, n, a, b, q, r, nsim, method, metric, type = 'Theoretical')
fig.fun('S6', m, n, a, b, q, r, nsim, method, metric, type = 'Correlation')
fig.fun('S7', m, n, a, b, q, r, nsim, method, metric, type = 'Correlation')
fig.fun('S8', m, n, a, b, q, r, nsim, method, metric, type = 'Correlation')
fig.fun('S9', m, n, a, b, q, r, nsim, method, metric, type = 'Correlation')
fig.fun('S10', m, n, a, b, q, r, nsim, method, metric, type = 'Non-parametric')
fig.fun('S11', m, n, a, b, q, r, nsim, method, metric, type = 'Non-parametric')
fig.fun('S12', m, n, a, b, q, r, nsim, method, metric, type = 'Non-parametric')
fig.fun('S13', m, n, a, b, q, r, nsim, method, metric, type = 'Non-parametric')
library(SAVER)
nsim <- 10
b <- 0.5
q <- 6
r <- 0
iterlim <- 5
s <- 1
m.vec <- c(100, 500, 1000, 1500, 2000, 2500, 3000)
n.vec <- c(80, 160, 320)
saver.run.time <- function(alp0, alp1, pi, m, n, a, b, q, r, Z, U, iterlim) {
data <- data.generation(alp0, alp1, pi, m, n, a, b, q, r, Z, U)
W <- data$W
t <- system.time(res.saver <- saver(as.data.frame(W)))
return(t[1])
}
bmdd_fit_on_combo <- readRDS("bmdd_fit_on_combo.rds")
fit <- bmdd_fit_on_combo$res[[s]]
pi <- fit$pi
alp0 <- fit$alpha$alp0
alp1 <- fit$alpha$alp1
Z <- NULL
U <- NULL
if(s == 2) {
Z <- bmdd_fit_on_combo$cova$Z1
} else if(s == 3) {
Z <- bmdd_fit_on_combo$cova$Z2
} else if(s == 4) {
U <- bmdd_fit_on_combo$cova$U1
} else if(s == 5) {
U <- bmdd_fit_on_combo$cova$U2
}
lm <- length(m.vec)
ln <- length(n.vec)
setting <- cbind(rep(m.vec, each = ln), rep(n.vec, lm))
l <- nrow(setting)
nsim <- 10
library(doSNOW)
cl <- makeCluster(10, type = "SOCK")
registerDoSNOW(cl)
output <- foreach(ii = 1 : nsim, .combine = 'rbind') %dopar% {
library(saver)
source('data_generation.R')
#source('bmdd2.R')
library(foreach)
sink(paste0('output/saver_run_time/time', s, '_', ii, '.txt'))
t <- foreach(jj = 1 : l) %do% {
para <- setting[jj, ]
m <- para[1]
n <- para[2]
a <- 1000 * (m / 100) ^ (1 / 1.5)
set.seed(ii)
res <- saver.run.time(alp0, alp1, pi, m, n, a, b, q, r, Z, U, iterlim)
print(jj)
res
}
sink()
unlist(t)
}
output <- foreach(ii = 1 : nsim, .combine = 'rbind') %dopar% {
library(SAVER)
source('data_generation.R')
#source('bmdd2.R')
library(foreach)
sink(paste0('output/saver_run_time/time', s, '_', ii, '.txt'))
t <- foreach(jj = 1 : l) %do% {
para <- setting[jj, ]
m <- para[1]
n <- para[2]
a <- 1000 * (m / 100) ^ (1 / 1.5)
set.seed(ii)
res <- saver.run.time(alp0, alp1, pi, m, n, a, b, q, r, Z, U, iterlim)
print(jj)
res
}
sink()
unlist(t)
}
library(doSNOW)
cl <- makeCluster(10, type = "SOCK")
registerDoSNOW(cl)
output <- foreach(ii = 1 : nsim, .combine = 'rbind') %dopar% {
library(SAVER)
source('data_generation.R')
#source('bmdd2.R')
library(foreach)
sink(paste0('output/saver_run_time/time', s, '_', ii, '.txt'))
t <- foreach(jj = 1 : l) %do% {
para <- setting[jj, ]
m <- para[1]
n <- para[2]
a <- 1000 * (m / 100) ^ (1 / 1.5)
set.seed(ii)
res <- saver.run.time(alp0, alp1, pi, m, n, a, b, q, r, Z, U, iterlim)
print(jj)
res
}
sink()
unlist(t)
}
library(SAVER)
source('data_generation.R')
#source('bmdd2.R')
library(foreach)
t <- foreach(jj = 1 : l) %do% {
para <- setting[jj, ]
m <- para[1]
n <- para[2]
a <- 1000 * (m / 100) ^ (1 / 1.5)
set.seed(ii)
res <- saver.run.time(alp0, alp1, pi, m, n, a, b, q, r, Z, U, iterlim)
print(jj)
res
}
ii=1
t <- foreach(jj = 1 : l) %do% {
para <- setting[jj, ]
m <- para[1]
n <- para[2]
a <- 1000 * (m / 100) ^ (1 / 1.5)
set.seed(ii)
res <- saver.run.time(alp0, alp1, pi, m, n, a, b, q, r, Z, U, iterlim)
print(jj)
res
}
t
library(foreach)
library(ggplot2)
fig.fun <- function(setup, m = NULL, n = NULL, a = NULL, b = NULL, q = NULL, r = NULL,
nsim, method, metric, type, robust = FALSE) {
if(type == 'Non-parametric') {
output.folder <- paste0('output/', setup, '/m_', m, '_n_', n, '/')
} else {
output.folder <- paste0('output/', setup, '/m_', m, '_n_', n, '_a_', a,
'_b_', b, '_q_', q, '_r_', r, '/')
}
output.raw <- foreach(i = 1 : nsim, .combine = 'rbind') %do% {
res <- readRDS(paste0(output.folder, i, ".rds"))
res$res
}
s <- nrow(output.raw) / nsim
k <- s / 2
l <- ncol(output.raw)
if(l == 11) {
ind <- c(1, 4, 8, 2, 3, 5 : 7, 9 : 11)
} else if(l == 14) {
ind <- c(1, 12, 4, 8, 2, 13, 3, 14, 5 : 7, 9 : 11)
} else if(l == 12) {
ind <- c(1, 12, 4, 8, 2, 3, 5 : 7, 9 : 11)
}
method <- method[ind]
output.raw <- output.raw[, ind]
output <- foreach (i = 1 : s, .combine = 'rbind') %do% {
res <- output.raw[seq(i, nsim * s, s), ]
est <- colMeans(res, na.rm = TRUE)
num.nan <- colSums(matrix(!is.na(res), nrow = nsim))
est.sd <- sqrt(rowSums((t(res) - est) ^ 2, na.rm = TRUE) / ((num.nan - 1) * num.nan))
return(c(est, est.sd))
}
M <- output[1 : k, 1 : l][-c(2, 3), ]
tmp1 <- (M[, -1] - M[, 1]) / M[, -1]
tmp2 <- (M[, 1] - M[, -1]) / M[, 1]
A <- tmp1 * (tmp1 > 0) - tmp2 * (tmp2 > 0)
colnames(A) <- method[-1]
A[A < 0] <- A[A < 0] / 10
method1 <- factor(1 : (l - 1), labels = method[-1])
df <- data.frame(method = rep(method1, each = k - 2),
value = as.vector(A))
custom_breaks <- c(1, 0.5, 0, -0.05, -0.1)
custom_labels <- c("100%", "50%", "0%", "50%", "100%")
pdf(paste0(setup,'_boxplot_gp.pdf'), width = 12, height = 8)
gp <- ggplot(df, aes(x = method, y = value))  +
geom_boxplot(fill = "steelblue", color = "black", na.rm = TRUE) +
theme_minimal(base_size = 25) +
scale_y_continuous(
breaks = custom_breaks,
labels = custom_labels
) +
xlab("") +
ylab("BMDD Improvement Percentage") +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
plot.margin = unit(c(0.5,0.5,-0.5,0.5), "cm")) +
geom_hline(yintercept = 0, color = "black", linetype = "dashed", size = 1)
print(gp)
dev.off()
}
method <- c('BMDD', 'mbDenoise', 'mbImpute', 'SAVER', 'scImpute', 'ALRA', 'DMM',
'naive-1', 'naive-2', 'naive-3', 'naive-4')
metric <- c('Mean squared error', 'Sample-wise correlation', 'Taxon-wise correlation',
'Sample-wise distance', 'Taxon-wise distance',
'Shannon\'s index', 'Simpson\'s index', 'Bray-Curtis dissimilarity',
'Kullback–Leibler divergence', 'Jensen–Shannon divergence', 'Hellinger distance',
'Gini coefficient', '(Mean, Standard deviation)', 'Coefficient of variation',
'Kolmogorov–Smirnov distance', 'Wasserstein distance', 'Pairwise taxon-to-taxon correlation')
nsim <- 10
m <- 100
n <- 80
a <- 1000
b <- 0.5
q <- 6
r <- 0
setup = 'S1'
robust = FALSE
type = 'Theoretical'
if(type == 'Non-parametric') {
output.folder <- paste0('output/', setup, '/m_', m, '_n_', n, '/')
} else {
output.folder <- paste0('output/', setup, '/m_', m, '_n_', n, '_a_', a,
'_b_', b, '_q_', q, '_r_', r, '/')
}
output.raw <- foreach(i = 1 : nsim, .combine = 'rbind') %do% {
res <- readRDS(paste0(output.folder, i, ".rds"))
res$res
}
s <- nrow(output.raw) / nsim
k <- s / 2
l <- ncol(output.raw)
if(l == 11) {
ind <- c(1, 4, 8, 2, 3, 5 : 7, 9 : 11)
} else if(l == 14) {
ind <- c(1, 12, 4, 8, 2, 13, 3, 14, 5 : 7, 9 : 11)
} else if(l == 12) {
ind <- c(1, 12, 4, 8, 2, 3, 5 : 7, 9 : 11)
}
method <- method[ind]
output.raw <- output.raw[, ind]
output <- foreach (i = 1 : s, .combine = 'rbind') %do% {
res <- output.raw[seq(i, nsim * s, s), ]
est <- colMeans(res, na.rm = TRUE)
num.nan <- colSums(matrix(!is.na(res), nrow = nsim))
est.sd <- sqrt(rowSums((t(res) - est) ^ 2, na.rm = TRUE) / ((num.nan - 1) * num.nan))
return(c(est, est.sd))
}
M <- output[1 : k, 1 : l][-c(2, 3), ]
tmp1 <- (M[, -1] - M[, 1]) / M[, -1]
tmp2 <- (M[, 1] - M[, -1]) / M[, 1]
A <- tmp1 * (tmp1 > 0) - tmp2 * (tmp2 > 0)
colnames(A) <- method[-1]
A[A < 0] <- A[A < 0] / 10
method1 <- factor(1 : (l - 1), labels = method[-1])
df <- data.frame(method = rep(method1, each = k - 2),
value = as.vector(A))
custom_breaks <- c(1, 0.5, 0, -0.05, -0.1)
custom_labels <- c("100%", "50%", "0%", "50%", "100%")
gp <- ggplot(df, aes(x = method, y = value))  +
geom_boxplot(fill = "steelblue", color = "black", na.rm = TRUE) +
theme_minimal(base_size = 25) +
scale_y_continuous(
breaks = custom_breaks,
labels = custom_labels
) +
xlab("") +
ylab("BMDD Improvement Percentage") +
theme(axis.text.x = element_text(angle = 45, hjust = 1),
plot.margin = unit(c(0.5,0.5,-0.5,0.5), "cm")) +
geom_hline(yintercept = 0, color = "black", linetype = "dashed", size = 1)
print(gp)
library(ggplot2)
library(ggpubr)
W <- readRDS('res_bmdd_Daniel2018.rds')[[1]]
res.bmdd <- readRDS('res_bmdd_Daniel2018.rds')[[2]]
res.dmn <- readRDS('res_bmdd_Daniel2018.rds')[[3]]
theta <- as.vector(fitted(res.dmn))
################################################
library(ggplot2)
library(ggpubr)
W <- readRDS('res_bmdd_Daniel2018.rds')[[1]]
res.bmdd <- readRDS('res_bmdd_Daniel2018.rds')[[2]]
res.dmn <- readRDS('res_bmdd_Daniel2018.rds')[[3]]
theta <- as.vector(fitted(res.dmn))
theta.sum <- sum(theta)
beta <- res.bmdd$beta
Xhat <- t(t(beta) / colSums(beta))
X <- t(t(W) / colSums(W))
ind <- c(24, 48, 141, 173)
plot.fun <- function(k) {
j <- ind[k]
x <- X[j, ]
x <- x[x < quantile(x, 0.97)]
x1 <- seq(min(x), max(x), len = 1000)
y1 <- dbeta(x1, theta[j], theta.sum - theta[j])
x2 <- Xhat[j, ]
x2 <- x2[x2 < quantile(x2, 0.97)]
adj <- c(0.5, 1, 0.5, 0.5)
y.max <- c(30, 250, 20000, 15000)
gp <- ggplot() +
geom_histogram(aes(x = x, y = ..density..), #boundary = 0,
fill = 'steelblue', color = 'black') +
xlab('') + ylab('') +
theme_minimal(base_size = 25) +
geom_line(aes(x = x1, y = y1, color = "Dirichlet distribution"), size = 1.2) +
scale_y_continuous(limits = c(0, y.max[k])) +
stat_density(aes(x = x2, color = "BMDD"), size = 1.2, adjust = adj[k],
geom = "line", position = "identity") +
scale_color_manual(
name = "",
values = c("Dirichlet distribution" = "blue", "BMDD" = "red")
) +
theme(legend.position = "top")
if(k == 3) {
gp <- gp +
scale_x_continuous(
breaks = c(0, 0.00025, 0.0005, 0.00075),
labels = c("0e+00", "2.5e−04", "5e−04", "7.5e−04")
)
}
return(gp)
}
p1 <- plot.fun(1)
p2 <- plot.fun(2)
p3 <- plot.fun(3)
p4 <- plot.fun(4)
big_plot <- ggarrange(plotlist = list(p1, p2, p3, p4),
nrow = 2, ncol = 2, common.legend = TRUE)
final_plot <- annotate_figure(
big_plot,
bottom = text_grob("Proportion", size = 25),
left = text_grob("Density", size = 25, rot = 90)
)
final_plot
